#!/usr/bin/env python

gplheader = """Harmon Instruments CORDIC generator
Copyright (C) 2014 Harmon Instruments, LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/
"""

import sys, os, random
import numpy as np

def vint(n):
    nbits = int(1+np.ceil(np.log2(n+1)))
    return "{}'sd{}".format(nbits, int(n))

def sname(name, n):
    return "{}_{}".format(name, n)

def gen_port(name, pdir="in", bits=1, signed=False, last=False):
    print "\t{}put".format(pdir),
    if signed:
        print "signed",
    if bits > 1:
        print "[{}:0]".format(bits-1),
    if not last:
        print name + ","
    else:
        print name + ");"

def gen_addsub(out, sub, in1, in2):
    print "\t{0} <= ({1}) ? {2} - {3} : {2} + {3};".format(
        out, sub, in1, in2)

def cordic_angles(stages, bits):
    angles = np.arctan(2.0 ** (-1.0 * np.arange(stages-1)))
    angles = np.concatenate([[np.pi*0.5], angles])
    angles = np.round(angles * (2**(bits-1))/np.pi)
    return angles

def gen_cordic(name,
               stages = 20,
               nbits_din = 16,
               nbits_dout = 20,
               nbits_ain = 20):
    angles = cordic_angles(stages=stages, bits = nbits_ain)
    nbits_a = []
    nbits_d = []
    for i in range(stages):
        nbits_a.append(nbits_ain)
        nbits_d.append(nbits_dout)
    gain = 1.0
    for i in range(0, stages):
        gain *= np.sqrt(1.0 + 2.0 ** (-2.0*i))
    # header
    print "/* generated by " + gplheader 
    print "gain =", gain
    print "*/"
    print "module {} (".format(name)
    gen_port('clock', pdir='in')
    gen_port('ain', pdir = 'in', bits=nbits_ain, signed=True)
    gen_port('in_re, in_im', pdir = 'in', bits=nbits_din, signed=True)
    nbo = nbits_d[stages-1]
    gen_port('out_re, out_im', pdir = 'out', bits=nbo, signed=True, last=True)
       
    # declarations
    for i in range(stages):
        print "\treg signed [{}:0] angle_{} = 0;".format(nbits_a[i]-1, i)
        msb = nbits_d[i]-1
        print "\treg signed [{0}:0] real_{1} = 0, imag_{1} = 0;".format(msb, i)
    # assigns
    print "\tassign out_re = real_{};".format(stages-1)
    print "\tassign out_im = imag_{};".format(stages-1)
    # prerotate
    print "always @ (posedge clock) begin"
    print "\tangle_0 <= (ain >= 0) ? ain - {0} : ain + {0};".format(
        str(vint(angles[0])))
    gen_addsub('real_0', 'ain >= 0', "2'sd0", 'in_im')
    gen_addsub('imag_0', 'ain <  0', "2'sd0", 'in_re')
    # rotate stages
    for n in range(1, stages):
        sub = "({} >= 0)".format(sname('angle', n-1))
        gen_addsub(sname('angle', n), sub, sname('angle', n-1),vint(angles[n]))
        gen_addsub(sname('real',  n), ""+sub, sname('real', n-1),
                   sname('(imag', n-1) + " >>> {})".format(n-1))
        gen_addsub(sname('imag',  n), "~"+sub, sname('imag', n-1),  
                   sname('(real', n-1) + " >>> {})".format(n-1))
    print "end"
    print "endmodule"

def gen_translate(name,
                  stages = 20,
                  nbits_din = 19,
                  nbits_dout = 20,
                  nbits_aout = 20):
    nbits_a = stages
    angles = cordic_angles(stages=stages, bits = nbits_a)
    nbits_a = []
    nbits_d = []
    for i in range(stages):
        nbits_a.append(nbits_a)
        nbits_d.append(nbits_dout)
    gain = 1.0
    for i in range(0, stages):
        gain *= np.sqrt(1.0 + 2.0 ** (-2.0*i))
    # header
    print "/* generated by " + gplheader 
    print "gain =", gain
    print "*/"
    print "module {} (".format(name)
    gen_port('clock', pdir='in')
    gen_port('in_re, in_im', pdir = 'in', bits=nbits_din, signed=True)
    nbo = nbits_d[stages-1]
    gen_port('out_angle', pdir = 'out', bits=nbits_a, signed=True)
    gen_port('out_mag', pdir = 'out', bits=nbo-1, signed=False, last=True)
    
    # declarations
    for i in range(stages):
        print "\treg signed [{}:0] angle_{} = 0;".format(nbits_a[i]-1, i)
        msb = nbits_d[i]-1
        print "\treg signed [{0}:0] real_{1} = 0;".format(msb, i)
        if i != stages - 1:
            print "\treg signed [{0}:0] imag_{1} = 0;".format(msb, i)
    # assigns
    print "\tassign out_mag = real_{};".format(stages-1)
    print "\tassign out_angle = angle_{};".format(stages-1)
    print "always @ (posedge clock) begin"
    # prerotate - re = x, im = y, if y < 0, rotate 90 degrees ccw else rotate 90 ccw
    print "\tangle_0 <= (in_im < 0) ? 0 - {0} : 0 + {0};".format(
        str(vint(angles[0])))
    gen_addsub('real_0', 'in_im < 0', "2'sd0", 'in_im')
    gen_addsub('imag_0', 'in_im >=  0', "2'sd0", 'in_re')
    # rotate stages - first 6 use angle bits?
    # pre: same as in
    # 1: in + 1
    # 2: prev + 1
    for n in range(1, stages):
        sub = "({} < 0)".format(sname('imag', n-1))
        gen_addsub(sname('angle', n), sub, sname('angle', n-1),vint(angles[n]))
        gen_addsub(sname('real',  n), ""+sub, sname('real', n-1),
                   sname('(imag', n-1) + " >>> {})".format(n-1))
        if n != stages - 1:
            gen_addsub(sname('imag',  n), "~"+sub, sname('imag', n-1),
                       sname('(real', n-1) + " >>> {})".format(n-1))
    print "end"
    print "endmodule"
 
if __name__=="__main__":
    try: 
        arg = sys.argv[1]
    except:
        arg = 'rotate'
    if arg == 'translate':
        gen_translate("translate")
    else:
        gen_cordic("cordic")
    
