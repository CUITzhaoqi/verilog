#!/usr/bin/env python

gplheader = """Harmon Instruments CORDIC generator
Copyright (C) 2014 Harmon Instruments, LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/

"""

import sys, os, random
import numpy as np
from myhdl import *

def modbv_signed(nbits, init=0):
    return modbv(init, min=-1*2**(nbits-1), max = 2**(nbits-1))
def intbv_signed(nbits, init=0):
    return intbv(init, min=-1*2**(nbits-1), max = 2**(nbits-1))

def vint(n):
    nbits = int(np.ceil(np.log2(n+1)))
    return "{}'d{}".format(nbits, int(n))

def sname(name, n):
    return "{}_{}".format(name, n)

class Cordic_Rotate():
    def __init__(self,
                 nbits_din = 16,
                 nbits_dout = 20,
                 nbits_ain = 20,
                 nstages = None, 
                 name = "cordic"):
        self.hdl = "/* generated by " + gplheader + "*/\n"
        self.nbits_ain = nbits_ain
        self.nbits_din = nbits_din
        self.nbits_dout = nbits_dout
        self.name = name
        if nstages != None:
            self.stages = nstages
        else:
            self.stages = nbits_ain
        self.angles = np.arctan(2.0 ** (-1.0 * np.arange(self.stages-1)))
        self.angles = np.concatenate([[np.pi*0.5],self.angles])
        print self.angles*180.0/np.pi
        self.angles /= np.pi
        self.angles *= 2**(nbits_ain-1)
        self.angles = np.round(self.angles)
        print self.angles
        self.nbits_a = []
        self.nbits_d = []
        for i in range(self.stages):
            self.nbits_a.append(nbits_ain)
            self.nbits_d.append(nbits_dout)
        self.simcycles = 0
        self.gain = 1.0
        for i in range(0, self.stages):
            self.gain *= np.sqrt(1.0 + 2.0 ** (-2.0*i))
        print "gain = ", self.gain

    def gen_addsub(self, out, sub, in1, in2):
        self.hdl += "\tif({})\n".format(sub)
        self.hdl += "\t\t{0} <= {1} - {2};\n".format(out, in1, in2)
        self.hdl += "\telse\n"
        self.hdl += "\t\t{0} <= {1} + {2};\n".format(out, in1, in2)
    def gen_cordic(self):
        # header
        self.hdl += "module {} (\n".format(self.name)
        self.hdl += "\tinput clock,\n"
        self.hdl += "\tinput signed [{}:0] angle,\n".format(self.nbits_ain-1)
        self.hdl += "\tinput signed [{}:0] in_re, in_im,\n".format(self.nbits_din-1)
        self.hdl += "\toutput signed [{}:0] out_re, out_im\n".format(self.nbits_d[self.stages-1]-1)
        self.hdl += ");\n"
        # declarations
        for i in range(self.stages):
            self.hdl += "\treg signed [{}:0] angle_{} = 0;\n".format(self.nbits_a[i]-1, i)
            self.hdl += "\treg signed [{}:0] real_{} = 0;\n".format(self.nbits_d[i]-1, i)
            self.hdl += "\treg signed [{}:0] imag_{} = 0;\n".format(self.nbits_d[i]-1, i)
        # assigns
        self.hdl += "\tassign out_re = real_{};\n".format(self.stages-1)
        self.hdl += "\tassign out_im = imag_{};\n".format(self.stages-1)
        # prerotate
        self.hdl += "always @ (posedge clock)\nbegin\n"
        sub = "(angle >= 0)"
        self.hdl += "\tangle_0 <= (angle >= 0) ? angle - {0} : angle + {0};\n".format(str(vint(self.angles[0])))
        self.gen_addsub('real_0',     sub, "2'sd0", 'in_im')
        self.gen_addsub('imag_0', "~"+sub, "2'sd0", 'in_re')
        # rotate stages
        for n in range(1, self.stages):
            sub = "({} >= 0)".format(sname('angle', n-1))
            self.gen_addsub(sname('angle', n), sub, sname('angle', n-1), vint(self.angles[n]))
            self.gen_addsub(sname('real',  n), ""+sub, sname('real', n-1),  sname('(imag', n-1) + " >>> {})".format(n-1))
            self.gen_addsub(sname('imag',  n), "~"+sub, sname('imag', n-1),  sname('(real', n-1) + " >>> {})".format(n-1))
        self.hdl += "end\n"
        self.hdl += "endmodule"
        return self.hdl
    def write_hdl(self, filename):
        with open (filename, "w") as file:
            file.write(self.hdl)
    
    def sim_v(self, clock, angle, in_re, in_im, out_re, out_im):
        tb = "module tb;\n"
        tb += "reg clock = 0;\n" 
        tb += "reg signed [{}:0] angle = 0;\n".format(self.nbits_ain - 1)
        tb += "reg signed [{}:0] in_re, in_im;\n".format(self.nbits_din - 1)
        tb += "wire signed [{}:0] out_re, out_im;\n".format(self.nbits_dout - 1)
        tb += "initial begin\n"
        tb += '$dumpfile("sim/dump.vcd");\n'
        tb += "$dumpvars(0);\n"
        tb += "$from_myhdl(clock, angle, in_re, in_im);\n"
        tb += "$to_myhdl(out_re, out_im);\n"
        tb += "end\n"
        tb += "{} dut ".format(self.name)
        tb += "(.clock(clock), .angle(angle), .in_re(in_re), .in_im(in_im), .out_re(out_re), .out_im(out_im));\n"
        tb += "endmodule\n"
        with open ("sim/tb.v", "w") as file:
            file.write(tb)
        self.write_hdl("sim/cordic.v")
        r = os.system ("iverilog -DSIM -o sim/tb.vvp sim/tb.v sim/cordic.v")
        if r != 0:
            print "iverilog returned ", r
            exit(1)
        return Cosimulation("vvp -v -m /home/dlharmon/software/myhdl.vpi sim/tb.vvp", clock=clock, angle=angle, in_re=in_re, in_im=in_im, out_re = out_re, out_im = out_im)

    def check(self, out_re, out_im):
        dmult = 2**(self.nbits_din-1) - 1
        cin = self.stim_in[self.simcycles]
        in_re = int(np.real(cin*dmult))
        in_im = int(np.imag(cin*dmult))
        angle = int(2**(self.nbits_ain-1) * self.stim_angles[self.simcycles] / np.pi)
        if self.simcycles >= self.stages:
            idata = self.stim_in[self.simcycles-self.stages]
            iangle = self.stim_angles[self.simcycles-self.stages]
            odata = out_re + 1j*out_im
            odata /= dmult
            expected = idata * self.gain * np.exp(1j*iangle)
            error = np.abs(odata-expected)
            if error > 0.001:
                print "angle = ", iangle
                print "idata = ", idata
                print "odata = ", odata
                print "expected = ", expected
            print "error = ", error
        self.simcycles += 1
        if self.simcycles > len(self.stim_angles) - 1:
            raise StopSimulation
        return (angle, in_re, in_im)

    def bench(self):
        """ Test bench """
        angle = Signal(modbv_signed(self.nbits_ain))
        in_re = Signal(intbv_signed(self.nbits_din))
        in_im = Signal(intbv_signed(self.nbits_din))
        out_re = Signal(intbv_signed(self.nbits_dout))
        out_im = Signal(intbv_signed(self.nbits_dout))
        clock = Signal(bool(0))

        self.stim_angles = np.linspace(0, 2.0*np.pi, 1000)
        self.stim_in = np.exp(1j * self.stim_angles)
        np.random.shuffle(self.stim_in)
        #self.stim_in = np.ones(1000)
        dut = self.sim_v(clock, angle, in_re, in_im, out_re, out_im)
            
        @always(delay(2))
        def clockgen():
            clock.next = not clock
            
        @instance
        def check():
            while True:
                yield clock.negedge
                (angle.next, in_re.next, in_im.next) = self.check(out_re, out_im)
        return dut, clockgen, check

    def test_bench(self):
        tb = self.bench()
        sim = Simulation(tb)
        sim.run()
 
if __name__=="__main__":
    a = Cordic_Rotate()
    print a.gen_cordic()
    a.test_bench()
    
