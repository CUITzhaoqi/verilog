#!/usr/bin/env python

gplheader = """Harmon Instruments CORDIC generator
Copyright (C) 2014 Harmon Instruments, LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/
"""

import sys, os, random
import numpy as np

def vint(n):
    nbits = int(1+np.ceil(np.log2(n+1)))
    return "{}'sd{}".format(nbits, int(n))

def sname(name, n):
    return "{}_{}".format(name, n)

def gen_port(name, pdir="in", bits=1, signed=False, last=False):
    print "\t{}put".format(pdir),
    if signed:
        print "signed",
    if bits > 1:
        print "[{}:0]".format(bits-1),
    if not last:
        print name + ","
    else:
        print name + ");"

def gen_addsub(out, sub, in1, in2):
    print "\t{0} <= ({1}) ? {2} - {3} : {2} + {3};".format(
        out, sub, in1, in2)

def gen_cordic(name, 
               stages = 20,
               nbits_din = 16,
               nbits_dout = 20,
               nbits_ain = 20):
    angles = np.arctan(2.0 ** (-1.0 * np.arange(stages-1)))
    angles = np.concatenate([[np.pi*0.5], angles])
    print '/*', angles*180.0/np.pi, '*/'
    angles /= np.pi
    angles *= 2**(nbits_ain-1)
    angles = np.round(angles)
    print '/*', angles, '*/'
    nbits_a = []
    nbits_d = []
    for i in range(stages):
        nbits_a.append(nbits_ain)
        nbits_d.append(nbits_dout)
    gain = 1.0
    for i in range(0, stages):
        gain *= np.sqrt(1.0 + 2.0 ** (-2.0*i))
    # header
    print "/* generated by " + gplheader 
    print "gain =", gain
    print "*/"
    print "module {} (".format(name)
    gen_port('clock', pdir='in')
    gen_port('ain', pdir = 'in', bits=nbits_ain, signed=True)
    gen_port('in_re, in_im', pdir = 'in', bits=nbits_din, signed=True)
    nbo = nbits_d[stages-1]-1
    gen_port('out_re, out_im', pdir = 'out', bits=nbo, signed=True, last=True)
       
    # declarations
    for i in range(stages):
        print "\treg signed [{}:0] angle_{} = 0;".format(nbits_a[i]-1, i)
        msb = nbits_d[i]-1
        print "\treg signed [{0}:0] real_{1} = 0, imag_{1} = 0;".format(msb, i)
    # assigns
    print "\tassign out_re = real_{};".format(stages-1)
    print "\tassign out_im = imag_{};".format(stages-1)
    # prerotate
    print "always @ (posedge clock) begin"
    print "\tangle_0 <= (ain >= 0) ? ain - {0} : ain + {0};".format(
        str(vint(angles[0])))
    gen_addsub('real_0', 'ain >= 0', "2'sd0", 'in_im')
    gen_addsub('imag_0', 'ain <  0', "2'sd0", 'in_re')
    # rotate stages
    for n in range(1, stages):
        sub = "({} >= 0)".format(sname('angle', n-1))
        gen_addsub(sname('angle', n), sub, sname('angle', n-1),vint(angles[n]))
        gen_addsub(sname('real',  n), ""+sub, sname('real', n-1),
                   sname('(imag', n-1) + " >>> {})".format(n-1))
        gen_addsub(sname('imag',  n), "~"+sub, sname('imag', n-1),  
                   sname('(real', n-1) + " >>> {})".format(n-1))
    print "end"
    print "endmodule"

#    with open ("sim/tb.v", "w") as file:
 #       file.write(tb)

def check(self, out_re, out_im):
    dmult = 2**(self.nbits_din-1) - 1
    cin = self.stim_in[self.simcycles]
    in_re = int(np.real(cin*dmult))
    in_im = int(np.imag(cin*dmult))
    angle = int(2**(self.nbits_ain-1) * self.stim_angles[self.simcycles]/np.pi)
    if self.simcycles >= self.stages:
        idata = self.stim_in[self.simcycles-self.stages]
        iangle = self.stim_angles[self.simcycles-self.stages]
        odata = out_re + 1j*out_im
        odata /= dmult
        expected = idata * self.gain * np.exp(1j*iangle)
        error = np.abs(odata-expected)
        if error > 0.001:
            print "angle = ", iangle
            print "idata = ", idata
            print "odata = ", odata
            print "expected = ", expected
            print "error = ", error
    self.simcycles += 1
    if self.simcycles > len(self.stim_angles) - 1:
        raise StopSimulation
    return (angle, in_re, in_im)

def bench(self):
    """ Test bench """
    angle = Signal(modbv_signed(self.nbits_ain))
    in_re = Signal(intbv_signed(self.nbits_din))
    in_im = Signal(intbv_signed(self.nbits_din))
    out_re = Signal(intbv_signed(self.nbits_dout))
    out_im = Signal(intbv_signed(self.nbits_dout))
    clock = Signal(bool(0))
    
    self.stim_angles = np.linspace(0, 2.0*np.pi, 1000)
    self.stim_in = np.exp(1j * self.stim_angles)
    np.random.shuffle(self.stim_in)
        #self.stim_in = np.ones(1000)
    dut = self.sim_v(clock, angle, in_re, in_im, out_re, out_im)
            
    @always(delay(2))
    def clockgen():
        clock.next = not clock
        
    @instance
    def check():
        while True:
            yield clock.negedge
            (angle.next, in_re.next, in_im.next) = self.check(out_re, out_im)
 
if __name__=="__main__":
    gen_cordic("cordic")
    
    
