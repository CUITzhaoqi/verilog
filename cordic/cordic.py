#!/usr/bin/env python

gplheader = """Harmon Instruments CORDIC generator
Copyright (C) 2014 Harmon Instruments, LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/
"""

import sys, os
import numpy as np

def vint(n):
    nbits = int(1+np.ceil(np.log2(np.abs(n)+1)))
    return "{}'sd{}".format(nbits, int(n))

def sname(name, n):
    return "{}_{}".format(name, n)

def gen_port(name, pdir="in", bits=1, signed=False, last=False):
    print "\t{}put".format(pdir),
    if signed:
        print "signed",
    if bits > 1:
        print "[{}:0]".format(bits-1),
    if not last:
        print name + ","
    else:
        print name + ");"

def gen_addsub(out, sub, in1, in2):
    print "\t{0} <= ({1}) ? {2} - {3} : {2} + {3};".format(
        out, sub, in1, in2)

def cordic_angles(stages, bits):
    angles = np.arctan(2.0 ** (-1.0 * np.arange(stages-1)))
    angles = np.concatenate([[np.pi*0.5], angles])
    angles = angles * (2**(bits-1))/np.pi
    return angles

def gen_cordic(name,
               stages = 20,
               nbits_din = 16,
               nbits_dout = 20,
               nbits_ain = 20):
    angles = cordic_angles(stages=stages, bits = nbits_ain)
    angles = np.round(angles)
    nbits_a = []
    nbits_d = []
    for i in range(stages):
        nbits_a.append(nbits_ain)
        nbits_d.append(nbits_dout)
    gain = 1.0
    for i in range(0, stages):
        gain *= np.sqrt(1.0 + 2.0 ** (-2.0*i))
    # header
    print "/* generated by " + gplheader
    print "gain =", gain
    print "*/"
    print "module {} (".format(name)
    gen_port('clock', pdir='in')
    gen_port('ain', pdir = 'in', bits=nbits_ain, signed=True)
    gen_port('in_re, in_im', pdir = 'in', bits=nbits_din, signed=True)
    nbo = nbits_d[stages-1]
    gen_port('out_re, out_im', pdir = 'out', bits=nbo, signed=True, last=True)

    # declarations
    for i in range(stages):
        print "\treg signed [{}:0] angle_{} = 0;".format(nbits_a[i]-1, i)
        msb = nbits_d[i]-1
        print "\treg signed [{0}:0] real_{1} = 0, imag_{1} = 0;".format(msb, i)
    # assigns
    print "\tassign out_re = real_{};".format(stages-1)
    print "\tassign out_im = imag_{};".format(stages-1)
    # prerotate
    print "always @ (posedge clock) begin"
    print "\tangle_0 <= (ain >= 0) ? ain - {0} : ain + {0};".format(
        str(vint(angles[0])))
    gen_addsub('real_0', 'ain >= 0', "2'sd0", 'in_im')
    gen_addsub('imag_0', 'ain <  0', "2'sd0", 'in_re')
    # rotate stages
    for n in range(1, stages):
        sub = "({} >= 0)".format(sname('angle', n-1))
        gen_addsub(sname('angle', n), sub, sname('angle', n-1),vint(angles[n]))
        gen_addsub(sname('real',  n), ""+sub, sname('real', n-1),
                   sname('(imag', n-1) + " >>> {})".format(n-1))
        gen_addsub(sname('imag',  n), "~"+sub, sname('imag', n-1),
                   sname('(real', n-1) + " >>> {})".format(n-1))
    print "end"
    print "endmodule"

def gen_angle_rom(bits, angles):
    print "\treg signed [{}:0] arom[0:63];".format(bits-1)
    print "initial begin"
    for i in range(64):
        val = 0
        bval = '{:06b}'.format(i)
        bval = bval[::-1]
        for j in range(6):
            if bval[j] == '0':
                val += angles[j]
            else:
                val -= angles[j]
        if np.abs(val) >= 2**(bits-1):
            val = 0
        print "\tarom[{}] = {};".format(i, int(np.round(val)))
    print "end"

def gen_translate(name,
                  stages = 20,
                  nbits_din = 19,
                  nbits_dout = 20,
                  nbits_aout = 20):
    nbits_ain = stages
    angles = cordic_angles(stages=stages, bits = nbits_ain)
    nbits_a = []
    nbits_d = []
    for i in range(stages):
        nbits_a.append(nbits_ain)
        nbits_d.append(nbits_dout)
    gain = 1.0
    for i in range(0, stages):
        gain *= np.sqrt(1.0 + 2.0 ** (-2.0*i))
    # header
    print "/* generated by " + gplheader
    print "gain =", gain
    print "*/"
    print "module {} (".format(name)
    gen_port('clock', pdir='in')
    gen_port('in_re, in_im', pdir = 'in', bits=nbits_din, signed=True)
    nbo = nbits_d[stages-1]
    gen_port('out_angle', pdir = 'out', bits=nbits_ain, signed=True)
    gen_port('out_mag', pdir = 'out', bits=nbo-1, signed=False, last=True)
    gen_angle_rom(nbits_ain, angles)
    angles = np.round(angles)
    # declarations
    for i in range(stages):
        if i < 6:
            print "\treg [{0}:0] angle_{0} = 0;".format(i)
        else:
            print "\treg signed [{0}:0] angle_{1} = 0;".format(nbits_a[i]-1, i)
        msb = nbits_d[i]-1
        print "\treg [{0}:0] re_{1} = 0;".format(msb-1, i)
        if i != stages - 1:
            if i > 1:
                msb -= (i-1)
            print "\treg signed [{0}:0] im_{1} = 0;".format(msb, i)
    # assigns
    print "\tassign out_mag = re_{};".format(stages-1)
    print "\tassign out_angle = angle_{};".format(stages-1)
    print "always @ (posedge clock) begin"
    # prerotate - re = x, im = y,
    # if y < 0, rotate 90 degrees ccw else rotate 90 ccw
    print "\tangle_0 <= (in_im < 0);"
    print "\tre_0 <= in_im < 0 ? 2'sd0 - in_im : in_im;"
    print "\tim_0 <= in_im < 0 ? in_re : 2'sd0 - in_re;"
    # rotate stages
    # pre: same as in
    # 1: in + 1
    # 2: prev + 1
    for n in range(1, stages):
        sub = "im_{} < 0".format(n-1)
        if n < 6:
            print "\tangle_{0} <= {{{1}, angle_{2}}};".format(n, sub, n-1)
        elif n == 6:
            gen_addsub('angle_6',
                       sub,
                       'arom[angle_5]',
                       vint(angles[6])
                       )
        else:
            gen_addsub('angle_{}'.format(n),
                       sub,
                       'angle_{}'.format(n-1),
                       vint(angles[n])
                       )
        if n < 11: # fixme
            im_shifted = '(im_{0} >>> {0})'.format(n-1)
            abs_im = "(im_{0} < 0 ? 2'sd0 - {1} : {1})".format(n-1, im_shifted)
            print "\tre_{0} <= $signed(re_{1}) + {2};".format(n, n-1, abs_im)
        else:
            print "\tre_{} <= re_{};".format(n, n-1)
        if n != stages - 1:
            gen_addsub(sname('im',  n),
                       "{} >= 0".format(sname('im', n-1)),
                       sname('im', n-1),
                       sname('(re', n-1) + " >> {})".format(n-1))
    print "end"

    print """initial
     begin
        $dumpfile("dump.vcd");
        $dumpvars(0);
     end"""

    print "endmodule"

if __name__=="__main__":
    try:
        arg = sys.argv[1]
    except:
        arg = 'rotate'
    if arg == 'translate':
        gen_translate("translate")
    else:
        gen_cordic("cordic")

